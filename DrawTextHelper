package com.kuaishou.ad.creative.center.util;

import static com.kuaishou.framework.process.ProcessUtils.run;
import static org.apache.commons.lang3.StringUtils.contains;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontFormatException;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Transparency;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.awt.image.RenderedImage;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Properties;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.annotation.PostConstruct;
import javax.imageio.ImageIO;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

import com.google.common.math.DoubleMath;
import com.kuaishou.framework.process.ProcessUtils;
import com.kuaishou.framework.util.trie.Trie;
import com.kuaishou.framework.util.trie.TrieUtils;
import com.kuaishou.framework.util.trie.TrieUtils.Fragment;
import com.kuaishou.util.EmojiImageManager;
import com.kuaishou.util.SpecialCharUtil;

/**
 * java8æ”¯æŒçš„æ˜¯ unicode 6.4 ï¼Œè€Œç›®å‰ios 10.2 å·²ç»æ”¯æŒunicode 9äº†
 *
 * CHECKSTYLE:OFF
 * è¦æ”¹çš„æ—¶å€™è¯·ç”¨ä»¥ä¸‹ä¾‹å­è¯•è¯•ç”»å‡ºçš„ç»“æœæ˜¯å¦æ­£å¸¸ï¼š
 *
 * 1ï¸âƒ£+1ï¸âƒ£=3ï¸âƒ£ï¸
 * ğŸ™ï¸  ğŸ’ğŸ’‹ â¤ï¸ â˜˜ï¸ âœï¹æœ¨å­ï¹ ï¼ˆâœºÏ‰âœºï¼‰ğŸ”¥ğŸ‘€â˜ºåä¸€å¹´ğŸŒ™^_^ğŸ˜„ï¸
 * Localï»¬ â‚¯ã•Â Â â¦Î¶à¸±Í¡âœ¾_é»„æ¯› âœæ‚ ç„¶â„³à¹“*** â¦â‚¯ã• âºŒï¹éˆŠç¢æ— ç‹  Â¨â„¡ âœï¹â„³à¹“â‚¯ã• â€
 *
 * è¿˜æœ‰ä¸€ç§ç‰¹æ®Šæƒ…å†µéœ€è¦ç‰¹åˆ«æ³¨æ„ï¼Œä»¥ä¸‹ä¸‰ç§ç»“æ„æ˜¾ç¤ºæ˜¯ä¸€æ ·çš„ï¼ˆæ“¦ï¼Œæ“¦ï¼Œæ“¦ï¼‰
 *      \\u38 \\ufe0f \\u20e3
 *      \\u38 \\u20e3 \\ufe0f
 *      \\u38 \\ufe0f \\u20e3 \\ufe0f
 * CHECKSTYLE:ON
 *
 * @author ligang
 *         create at: 2016-08-26 15:30
 */
@Lazy
@Component
public class DrawTextHelper {

    private static Logger logger = LoggerFactory.getLogger(DrawTextHelper.class);
    private static final double HEIGHT_MAGIC_NUM = 1.3D; //å®Œå…¨ç”¨fontSizeä¼šæœ‰ä¸€å°éƒ¨åˆ†æ˜¾ç¤ºä¸å‡ºæ¥
    private static final double WIDTH_MAGIC_NUM = 1.6D; //å®Œå…¨ä¸€æ ·ä¼šæ˜¾ç¤ºä¸å‡ºæ¥å•Š
    private static final float STROKE_TRANSPARENCY = 0.2f;
    private static final float[] STROKE_DASH_ARRAY = new float[] {1, 0.4f, 1.5f};
    private static final float ALPHA_COMPOSITE_ALPHA_VALUE_DEFAULT = 1.0f;

    // U+FEOF æ˜¯è¡¨ç¤ºè¿™ä¸ªå­—ç¬¦æ˜¯å½©è‰²çš„åº”è¯¥æ˜¾ç¤ºä¸ºEMOJIè¡¨æƒ…ï¼Œå¦‚æœä¸åŠ çš„è¯ä¼šæ›´åƒæ–‡æœ¬æ ·å¼ å¦‚ï¼šâ„
    // ä½†æ˜¯åœ¨æœ€æ–°çš„unicodeä¸­ä¸éœ€è¦FEOFä¹Ÿå·²ç»æ˜¯å½©è‰²çš„äº†ï¼Œåœ¨iPhoneä¸­åŠ ä¸åŠ FEOF "â„" ä¹Ÿä¼šæ˜¾ç¤ºä¸ºå½©è‰²çš„ï¼Œè€Œåœ¨macä¸­å°±å¿…é¡»æ˜¯ "â„ï¸"
    private static final String UNICODE_COLOR_STYLE_MARK = "\uFE0F";

    private static final String[] SUPPORT_LANGUAGES = {"Chinese Support", "Arabic Support",
            "French Support", "German Support", "Tibetan Support", "Mongolian Support",
            "Indonesian Support", "Malay Support", "Portuguese Support", "Tagalog Support",
            "Russian Support"};

    private static final String FONT_BASE_DIR = "/home/web_server/kuaishou-runner/webapps/";
    //private static final String FONT_BASE_DIR = "/Users/liqing/ks-project1/fonts/";


    private Font fontWQYMicrohei;
    private Font fontFZYouHJW509R;
    // æ€æºé»‘ä½“ Heavy
    private Font fontSourceHansSansScHeavy;
    // fontSourceHanSansCN-Light
    private Font fontSourceHanSansCNLight;
    // fontSourceHanSansCN-Regular
    private Font fontSourceHanSansCNRegular;
    private Font fontSourceHanSansCNMedium;
    // fontHiraginoSansGB
    private Font fontHiraginoSansGB;
    private Font fontAlteDIN1451Mittelschrift;
    private Font fontAlteDIN1451MittelschriftGepraegt;

    private boolean groupInstalled(String groupName) {
        try {
            String[] cmd = { "yum", "grouplist", "check", groupName };
            Process process = new ProcessBuilder() //
                    .command(cmd) //
                    .start();
            ProcessUtils.ProcessResult processResult = run(process);
            String output = processResult.getStdout();
            return contains(output, "Installed");
        } catch (Throwable e) {
            logger.error("[draw_text][check_install][error] groupName:{}", groupName, e);
            return false;
        }
    }

    private boolean isCentOS7() {
        try {
            String[] cmd = { "cat", "/etc/centos-release" };
            Process process = new ProcessBuilder() //
                    .command(cmd) //
                    .start();
            ProcessUtils.ProcessResult processResult = run(process);
            String output = processResult.getStdout();
            return contains(output, "CentOS Linux release 7");
        } catch (Throwable e) {
            logger.error("Error checking linux distribution", e);
            return false;
        }
    }

    @PostConstruct
    private void checkEnvironment() throws IOException, FontFormatException {
        File file = new File(FONT_BASE_DIR + "wqy-microhei.ttc.latest");
        // WQY
        if (file.exists()) {
            fontWQYMicrohei = Font.createFont(Font.TRUETYPE_FONT, file).deriveFont(Font.PLAIN);
            logger.info("[draw_text][init]load {} success!", file);
        } else {
            logger.warn("[draw_text][init] not found wqy-microhei.ttc");
        }
        // FZ
        file = new File(FONT_BASE_DIR + "FZYouHJW_509R.ttf");
        if (file.exists()) {
            fontFZYouHJW509R = Font.createFont(Font.TRUETYPE_FONT, file).deriveFont(Font.PLAIN);
            logger.info("[draw_text][init]load {} success!", file);
        } else {
            logger.warn("[draw_text][init] not found FZYouHJW_509R.ttf");
        }
        // SiYuan
        file = new File(FONT_BASE_DIR + "SourceHanSansSC-Heavy.otf");
        if (file.exists()) {
            fontSourceHansSansScHeavy = Font.createFont(Font.TRUETYPE_FONT, file)
                    .deriveFont(Font.PLAIN);
            logger.info("[draw_text][init]load {} success!", file);
        } else {
            logger.warn("[draw_text][init] not found SourceHanSansSC-Heavy.otf");
        }
        // fontSourceHanSansCN-Light
        file = new File(FONT_BASE_DIR + "SourceHanSansCN-Light.otf");
        if (file.exists()) {
            fontSourceHanSansCNLight = Font.createFont(Font.TRUETYPE_FONT, file)
                    .deriveFont(Font.PLAIN);
            logger.info("[draw_text][init]load {} success!", file);
        } else {
            logger.warn("[draw_text][init] not found fontSourceHanSansCN-Light.otf");
        }

        // font SourceHanSansCN-Regular
        file = new File(FONT_BASE_DIR + "SourceHanSansCN-Regular.otf");
        if (file.exists()) {
            fontSourceHanSansCNRegular = Font.createFont(Font.TRUETYPE_FONT, file)
                    .deriveFont(Font.PLAIN);
            logger.info("[draw_text][init]load {} success!", file);
        } else {
            logger.warn("[draw_text][init] not found fontSourceHanSansCN-Regular.otf");
        }

        // font SourceHanSansCN-Medium
        file = new File(FONT_BASE_DIR + "SourceHanSansCN-Medium.otf");
        if (file.exists()) {
            fontSourceHanSansCNMedium = Font.createFont(Font.TRUETYPE_FONT, file)
                    .deriveFont(Font.PLAIN);
            logger.info("[draw_text][init]load {} success!", file);
        } else {
            logger.warn("[draw_text][init] not found fontSourceHanSansCN-Regular.otf");
        }

        // font HiraginoSansGB
        file = new File(FONT_BASE_DIR + "HiraginoSansGB.ttc");
        if (file.exists()) {
            fontHiraginoSansGB = Font.createFont(Font.TRUETYPE_FONT, file)
                    .deriveFont(Font.PLAIN);
            logger.info("[draw_text][init]load {} success!", file);
        } else {
            logger.warn("[draw_text][init] not found fontSourceHanSansCN-Regular.otf");
        }

        // AlteDIN1451Mittelschrift ç”¨äºæ•°å­—
        file = new File(FONT_BASE_DIR + "alte-din-1451-mittelschrift.regular.ttf");
        if (file.exists()) {
            fontAlteDIN1451Mittelschrift = Font.createFont(Font.TRUETYPE_FONT, file).deriveFont(Font.PLAIN);
            logger.info("[draw_text][init]load {} success!", file);
        } else {
            logger.warn("[draw_text][init] not found alte-din-1451-mittelschrift.regular.ttf");
        }

        // AlteDIN1451MittelschriftGepraegt ç”¨äºç¼–è¾‘sdkæ°´å°åè´´ç‰‡
        file = new File(FONT_BASE_DIR + "alte-din-1451-mittelschrift.gepraegt.ttf");
        if (file.exists()) {
            fontAlteDIN1451MittelschriftGepraegt = Font.createFont(Font.TRUETYPE_FONT, file).deriveFont(Font.PLAIN);
            logger.info("[draw_text][init]load {} success!", file);
        } else {
            logger.warn("[draw_text][init] not found alte-din-1451-mittelschrift.gepraegt.ttf");
        }

        Properties props = System.getProperties();
        String osName = props.getProperty("os.name");
        if (osName.startsWith("Mac OS")) {
            return;
        }
        if (osName.startsWith("Linux") && isCentOS7()) {
            // do not check group in centos 7
            return;
        }
        // centos 6 or other conditions
        if (Stream.of(SUPPORT_LANGUAGES).anyMatch(s -> !groupInstalled(s))) {
            StringBuilder installCmd = new StringBuilder("yum groupinstall -y ");
            Stream.of(SUPPORT_LANGUAGES)
                    .forEach(s -> installCmd.append(" \"").append(s).append("\" "));
            throw new RuntimeException(
                    "[draw_text][init][error] nonsupport language , install command '"
                            + installCmd.toString() + "'");
        }
    }

    /**
     * @param bgColor ä¸ºnullæ—¶æ˜¯é€æ˜
     * @param shadowInfo é˜´å½±çš„é¢œè‰²å’Œå®½åº¦,å¦‚æœä¸åŠ é˜´å½±è¯·è®¾ç½®ä¸ºnull
     */
    public BufferedImage textToImage(String text, Color bgColor, Color fontColor, Font font,
            Pair<Color, Integer> shadowInfo) {
        //æœåŠ¡å™¨ä¸Šè£…äº†è—è¯­æ”¯æŒï¼Œè¿˜æ˜¯æœ‰éƒ¨åˆ†å­—ç”»ä¸å‡ºæ¥
        if (SpecialCharUtil.hasTibetan(text)) {
            return null;
        }

        Pair<BufferedImage, Integer> ret = createJpgByFontAndAlign(text, bgColor, fontColor, font, shadowInfo);
        if (ret != null) {
            return ret.getLeft();
        }
        return null;
    }

    public Pair<BufferedImage, Integer> textToImageWithRealWidth(String text, Color bgColor, Color fontColor, Font font,
            Pair<Color, Integer> shadowInfo, boolean ignoreUndisplayablePart) {
        return textToImageWithRealWidth(text, bgColor, fontColor, font, shadowInfo, ignoreUndisplayablePart, ALPHA_COMPOSITE_ALPHA_VALUE_DEFAULT);
    }

    public Pair<BufferedImage, Integer> textToImageWithRealWidth(String text, Color bgColor, Color fontColor, Font font,
            Pair<Color, Integer> shadowInfo, boolean ignoreUndisplayablePart, float alphaValue) {
        //æœåŠ¡å™¨ä¸Šè£…äº†è—è¯­æ”¯æŒï¼Œè¿˜æ˜¯æœ‰éƒ¨åˆ†å­—ç”»ä¸å‡ºæ¥
        if (SpecialCharUtil.hasTibetan(text)) {
            return null;
        }
        return createJpgByFontAndAlign(text, bgColor, fontColor, font, shadowInfo, ignoreUndisplayablePart, alphaValue);
    }

    private List<Fragment<Image>> validateTextAndGetMinimumDisplayableFragments(String text, Font font,
            boolean ignoreUndisplayablePart) {
        if (StringUtils.isBlank(text)) {
            return Collections.emptyList();
        }
        //æœåŠ¡å™¨ä¸Šè£…äº†è—è¯­æ”¯æŒï¼Œè¿˜æ˜¯æœ‰éƒ¨åˆ†å­—ç”»ä¸å‡ºæ¥
        if (SpecialCharUtil.hasTibetan(text) && !ignoreUndisplayablePart) {
            return Collections.emptyList();
        }

        return getMinimumDisplayableFragments(text, font, ignoreUndisplayablePart);
    }

    public Pair<List<RenderedImage>, List<Integer>> textToMultilineImageWithRealWidth(
            String text, Font font, Color fontColor, DrawTextLayoutParams textParams) {

        List<Fragment<Image>> minimumFragments = validateTextAndGetMinimumDisplayableFragments(text, font,
                textParams.isIgnoreUndisplayablePart());
        if (CollectionUtils.isEmpty(minimumFragments)) {
            return null;
        }
        List<RenderedImage> images = new ArrayList<>();
        List<Integer> imageWidths = new ArrayList<>();
        BufferedImage tmpImage = null;
        BufferedImage candidateImage = null;
        int candidateWidth = 0;
        int start = 0;
        int estimatedHeight = 0;
        int lineHeight = getTextImageHeight(font.getSize());
        int widthLimit = textParams.getWidthLimit();
        int heightLimit = textParams.getHeightLimit();
        int lineLimit = textParams.getLineLimit();
        int overlayMargin = textParams.getOverlayMargin();
        int lineGap = textParams.getLineGap();
        for (int line = 0; line < lineLimit; ++line) {
            int l = 0;
            int r = minimumFragments.size() - start - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                int end = start + mid + 1;
                List<Fragment<Image>> subFragmentList = minimumFragments.subList(start, end);
                if ((estimatedHeight + lineHeight * 2 > heightLimit || line == lineLimit - 1)
                        && end < minimumFragments.size()) {
                    // sublist is just a view!
                    subFragmentList = new ArrayList<>(subFragmentList);
                    subFragmentList.add(new Fragment<>(false, "...", null));
                }
                Pair<BufferedImage, Integer> tmpPair = createJpgByFontAndAlign(subFragmentList,
                        font, fontColor, null, null);
                tmpImage = tmpPair.getLeft();
                int width = tmpPair.getRight();
                if (width <= widthLimit) {
                    candidateImage = tmpImage;
                    candidateWidth = width;
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
            if (candidateImage != null) {
                images.add(candidateImage);
                imageWidths.add(candidateWidth);
                estimatedHeight += candidateImage.getHeight() + 2 * overlayMargin + lineGap;
                lineHeight = candidateImage.getHeight();
            }
            start += r + 1;
            if (start >= minimumFragments.size() || estimatedHeight + lineHeight + 2 * overlayMargin + lineGap > heightLimit) {
                break;
            }
        }
        if (images.isEmpty()) {
            return null;
        }
        return Pair.of(images, imageWidths);
    }

    private Pair<BufferedImage, Integer> createJpgByFontAndAlign(String text, Color bgColor, Color fontColor,
            Font font, Pair<Color, Integer> shadowInfo) {
        return createJpgByFontAndAlign(text, bgColor, fontColor, font, shadowInfo, false);
    }

    private List<Fragment<Image>> getMinimumDisplayableFragments(String text, Font font,
            boolean ignoreUndisplayablePart) {
        List<Fragment<Image>> fragments = getRawFragments(text, ignoreUndisplayablePart);

        return getMinimumDisplayableFragments(fragments, font, ignoreUndisplayablePart);
    }

    // æ¯ä¸ªèƒ½æ˜¾ç¤ºçš„æœ€å°å•ä½ç»„æˆä¸€ä¸ªfragment
    private List<Fragment<Image>> getMinimumDisplayableFragments(List<Fragment<Image>> fragments, Font font,
            boolean ignoreUndisplayablePart) {
        List<Fragment<Image>> ret = new ArrayList<>();

        for (Fragment<Image> fragment: fragments) {
            if (fragment.isEmoji()) {
                ret.add(fragment);
            } else {
                // this way may fail in international language, cause in language like Indian, one word may composed by several
                // chars, while in Chinese, it is ok
                for (char c: fragment.getKey().toCharArray()) {
                    if (font.canDisplay(c)) {
                        ret.add(new Fragment<>(fragment.isEmoji(), "" + c, fragment.getValue()));
                    } else if (!ignoreUndisplayablePart) {
                        throw new RuntimeException("[font][unsupported_char]" + c);
                    }
                }
            }
        }
        return ret;
    }

    private List<Fragment<Image>> getDisplayableParts(List<Fragment<Image>> fragments, Font font) {
        List<Fragment<Image>> ret = new ArrayList<>();

        for (Fragment<Image> fragment: fragments) {
            if (fragment.isEmoji()) {
                ret.add(fragment);
            } else {
                String text = fragment.getKey();
                int far = 0;
                while (far != -1 && text.length() > 0) {
                    far = font.canDisplayUpTo(text);
                    if (far == -1) {
                        ret.add(new Fragment<>(fragment.isEmoji(), text, fragment.getValue()));
                    } else {
                        if (far != 0) {
                            ret.add(new Fragment<>(fragment.isEmoji(), text.substring(0, far), fragment.getValue()));
                        }
                        text = text.substring(far + 1);
                    }
                }
            }
        }
        return ret;
    }

    private int getTextLengthFromFragments(List<Fragment<Image>> fragments) {
        int textLength = 0;
        for (Fragment<Image> fragment: fragments) {
            if (fragment.isEmoji()) {
                textLength += 1;
            } else {
                textLength += fragment.getKey().length();
            }
        }
        return textLength;
    }

    private int getTextImageHeight(int fontSize) {
        return DoubleMath.roundToInt(fontSize * HEIGHT_MAGIC_NUM, RoundingMode.UP);
    }

    private Pair<BufferedImage, Integer> createJpgByFontAndAlign(List<Fragment<Image>> fragments, Font font,
            Color fontColor, Color bgColor, Pair<Color, Integer> shadowInfo) {
        return createJpgByFontAndAlign(fragments, font, fontColor, bgColor, shadowInfo, ALPHA_COMPOSITE_ALPHA_VALUE_DEFAULT);
    }


    private Pair<BufferedImage, Integer> createJpgByFontAndAlign(List<Fragment<Image>> fragments, Font font,
            Color fontColor, Color bgColor, Pair<Color, Integer> shadowInfo, float alphaValue) {

        int textLength = getTextLengthFromFragments(fragments);

        int width = DoubleMath.roundToInt(textLength * font.getSize() * WIDTH_MAGIC_NUM,
                RoundingMode.UP);
        int height = getTextImageHeight(font.getSize());

        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = image.createGraphics();
        try {
            if (bgColor != null) {
                g.setBackground(bgColor);
            }
            g.setStroke(new BasicStroke(1));
            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); // å»é™¤é”¯é½¿(å½“è®¾ç½®çš„å­—ä½“è¿‡å¤§çš„æ—¶å€™,ä¼šå‡ºç°é”¯é½¿)

            int currentWidth = 0;

            g.setFont(font); // å­—ä½“å­—å½¢å­—å·

            for (Fragment<Image> node : fragments) {
                if (node.isEmoji()) { //emoji è¡¨æƒ…çš„è¯å°±åœ¨åé¢åŠ å›¾ç‰‡
                    Image bImageFromConvert = node.getValue();
                    g.drawImage(bImageFromConvert, currentWidth,
                            (int) (font.getSize() * (HEIGHT_MAGIC_NUM - 1) / 2), font.getSize(),
                            font.getSize(), null);
                    currentWidth += font.getSize();
                } else {
                    //å…ˆç”»é˜´å½±
                    if (shadowInfo != null) {
                        g.setColor(shadowInfo.getLeft());
                        g.drawString(node.getKey(), currentWidth,
                                shiftSouth(font.getSize(), 1));
                    }
                    //å­—ä½“æè¾¹
                    g.setColor(new Color(0, 0, 0, STROKE_TRANSPARENCY));
                    g.setStroke(new BasicStroke(2, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND, 1,
                            STROKE_DASH_ARRAY, 0));
                    //èƒŒæ™¯
                    AlphaComposite ac = AlphaComposite.getInstance(AlphaComposite.SRC_OVER,
                            alphaValue);
                    g.setComposite(ac);
                    //ç”»å­—
                    g.setColor(fontColor); // å­—çš„é¢œè‰²
                    g.drawString(node.getKey(), currentWidth, font.getSize()); // åœ¨æŒ‡å®šåæ ‡é™¤æ·»åŠ æ–‡å­—
                    currentWidth += g.getFontMetrics().stringWidth(node.getKey());
                }
            }
            return Pair.of(image, currentWidth);
        } finally {
            g.dispose();
        }
    }

    private List<Fragment<Image>> getRawFragments(String text, boolean ignoreUndisplayablePart) {
        Trie<Image> trie = EmojiImageManager.getInstance().getTrie();
        List<Fragment<Image>> fragments = TrieUtils.parseFragments(trie, text);

        // 1.å•ç‹¬çš„FEOFå»æ‰
        // 2.å­—ç¬¦ä¸­çš„ç¬¬ä¸€ä¸ªFEOFå»æ‰
        // 3.å¦‚æœè¿˜æœ‰ FEOF è¯´æ˜åˆå‡ºç°ä¸æ”¯æŒçš„ emoji
        fragments = fragments.stream()
                .filter(f -> f.isEmoji() || !f.getKey().equals(UNICODE_COLOR_STYLE_MARK)).map(f -> {
                    if (f.isEmoji()) {
                        return f;
                    }
                    String key = f.getKey();
                    if (key.startsWith(UNICODE_COLOR_STYLE_MARK)) {
                        key = key.replaceFirst(UNICODE_COLOR_STYLE_MARK, "");
                    }
                    if (key.contains(UNICODE_COLOR_STYLE_MARK)) {
                        if (ignoreUndisplayablePart) {
                            key = key.replaceAll(UNICODE_COLOR_STYLE_MARK, "");
                        } else {
                            throw new RuntimeException("[font][unsupported_emoji]" + text);
                        }
                    }
                    return new Fragment<>(f.isEmoji(), key, f.getValue());
                }).collect(Collectors.toList());
        return fragments;
    }


    private Pair<BufferedImage, Integer> createJpgByFontAndAlign(String text, Color bgColor, Color fontColor,
            Font font, Pair<Color, Integer> shadowInfo, boolean ignoreUndisplayablePart) {
        return createJpgByFontAndAlign(text, bgColor, fontColor, font, shadowInfo, ignoreUndisplayablePart, ALPHA_COMPOSITE_ALPHA_VALUE_DEFAULT);
    }

    /**
     * @param bgColor ä¸ºnullæ—¶æ˜¯é€æ˜
     * @param shadowInfo é˜´å½±çš„é¢œè‰²å’Œå®½åº¦,å¦‚æœä¸åŠ é˜´å½±è¯·è®¾ç½®ä¸ºnull
     * @param ignoreUndisplayablePart ä¸ºtrueåˆ™æŠ›å¼ƒæ— æ³•æ¸²æŸ“çš„éƒ¨åˆ†ï¼Œä¸ºfalseåˆ™å›è½åˆ°ç³»ç»Ÿå­—ä½“
     * @param alphaValue ä¸ºå­—ä½“çš„é€æ˜åº¦
     */
    private Pair<BufferedImage, Integer> createJpgByFontAndAlign(String text, Color bgColor, Color fontColor,
            Font font, Pair<Color, Integer> shadowInfo, boolean ignoreUndisplayablePart, float alphaValue) {

        List<Fragment<Image>> fragments = getRawFragments(text, ignoreUndisplayablePart);

        Font fontLocal = font;
        if (ignoreUndisplayablePart) {
            fragments = getDisplayableParts(fragments, font);
        } else {
            //å¦‚æœæœ‰ä»»ä½•ä¸€ä¸ªå­—ç¬¦ä¸èƒ½ä½¿ç”¨æŒ‡å®šfontæ¥ç”»ï¼Œé‚£ä¹ˆå°±æ•´ä¸ªå›è½åˆ°ç³»ç»Ÿå­—ä½“
            fontLocal = fragments.stream()
                    .anyMatch(n -> !n.isEmoji() && font.canDisplayUpTo(n.getKey()) != -1)
                        ? new Font(null, Font.PLAIN, font.getSize()) : font;
        }

        if (!font.getFontName().equals(fontLocal.getFontName())) {
            logger.warn("[font][unsupported_text] font:{}, text:{} ", font, text);
        }

        try {
            return createJpgByFontAndAlign(fragments, fontLocal, fontColor, bgColor, shadowInfo, alphaValue);
        } catch (Exception e) {
            logger.error("[draw_text][error] text:{}", text, e);
            return null;
        }
    }

    private static int[] getWidthAndHeight(String text, Font font) {
        Rectangle2D r = font.getStringBounds(text, new FontRenderContext(
                AffineTransform.getScaleInstance(1, 1), false, false));
        int unitHeight = (int) Math.floor(r.getHeight()); //
        // è·å–æ•´ä¸ªstrç”¨äº†fontæ ·å¼çš„å®½åº¦è¿™é‡Œç”¨å››èˆäº”å…¥å+1ä¿è¯å®½åº¦ç»å¯¹èƒ½å®¹çº³è¿™ä¸ªå­—ç¬¦ä¸²ä½œä¸ºå›¾ç‰‡çš„å®½åº¦
        int width = (int) Math.round(r.getWidth()) + 1;
        // æŠŠå•ä¸ªå­—ç¬¦çš„é«˜åº¦+3ä¿è¯é«˜åº¦ç»å¯¹èƒ½å®¹çº³å­—ç¬¦ä¸²ä½œä¸ºå›¾ç‰‡çš„é«˜åº¦
        int height = unitHeight + 3;
        return new int[] {width, height};
    }
    public static byte[] createImage(String str, Font font) throws Exception {
        int[] arr = getWidthAndHeight(str, font);
        int width = arr[0];
        int height = arr[1];
        BufferedImage image = new BufferedImage(width, height,
                BufferedImage.TYPE_INT_BGR);
        Graphics2D g2 = image.createGraphics();
        // å¢åŠ ä¸‹é¢ä»£ç ä½¿å¾—èƒŒæ™¯é€æ˜
        image = g2.getDeviceConfiguration().createCompatibleImage(width, height, Transparency.TRANSLUCENT);
        g2.dispose();
        g2 = image.createGraphics();

        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);
        g2.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);
        //shadowGraphics.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints
        // .VALUE_ALPHA_INTERPOLATION_QUALITY);

        FontRenderContext frc = g2.getFontRenderContext();
        TextLayout tl = new TextLayout(str, font, frc);
        Shape sha = tl.getOutline(AffineTransform.getTranslateInstance(0, height - 10));
        g2.setStroke(new BasicStroke(3.0f));
        g2.setColor(Color.BLACK);
        g2.draw(sha);
        g2.setColor(Color.WHITE);
        g2.fill(sha);
        g2.dispose();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        ImageIO.write(image, "png", baos);
        baos.flush();
        //ä½¿ç”¨toByteArray()æ–¹æ³•è½¬æ¢æˆå­—èŠ‚æ•°ç»„
        byte[] imageInByte = baos.toByteArray();

        return imageInByte;
    }


    private int shiftSouth(int p, int distance) {
        return (p + distance);
    }

    public Font getFontWQYMicrohei() {
        return fontWQYMicrohei;
    }

    public Font getFontFZYouHJW509R() {
        return fontFZYouHJW509R;
    }

    public Font getFontSourceHansSansScHeavy() {
        return fontSourceHansSansScHeavy;
    }

    public Font getFontSourceHanSansCNLight() {
        return fontSourceHanSansCNLight;
    }

    public Font getFontSourceHanSansCNRegular() {
        return fontSourceHanSansCNRegular;
    }

    public Font getHiraginoSansGB() {
        return fontHiraginoSansGB;
    }

    public Font getFontAlteDIN1451Mittelschrift() {
        return fontAlteDIN1451Mittelschrift;
    }

    public Font getFontSourceHanSansCNMedium() {
        return fontSourceHanSansCNMedium;
    }

    public Font getFontAlteDin1451MitteLschriftGepraegt() {
        return fontAlteDIN1451MittelschriftGepraegt;
    }
}
